# 기술 면접 대비 정보 정리
## 목차

*<종류 별 목차>*

>[1. 배열과 선형 리스트](#배열과-선형-리스트)
><br>[2. 선형 리스트](#선형-리스트)
><br>[3. 연결 리스트](#linkedlist)
><br>[4. 반복자(Iterator)](#반복자)
><br>[++추가 큐와 선형큐](./Queue-Description.md)
><br>[5. 이진탐색트리(Binary Search Tree) ](#이진-탐색-트리)
><br>[6. 해시테이블(Hash Table) ](#해시-테이블)
><br>[7. 각종 정렬](./Sorts.md)
><br>[8. 다익스트라 알고리즘](./Dijkstra-Algorithm.md)
><br>[9. A* 알고리즘](./Astar.md)
## 배열과 선형 리스트

### 1. Array, List, LinkedList 차이는?


Array 는 선언할때 **크기** 와 **데이터 타입**을 지정해야한다.
List,LinkedList 는 데이터 타입만 지정해주면된다.

``` cs
//Array
int[] intArr = new int[10];
string[] stringArr = new string[5];

//List
List<int> intList = new List<int>();
List<string> stringList = new List<string>();

//LinkedList
LinkedList<string> linkedlist = new LinkedList<string>();

```

이와 같이

**Array** 는 메모리 공간에 할당할 사이즈를 미리 정해두고 사용하는 자료구조이다.
따라서 데이터 크기를 알 수 없거나, 사이즈가 변동 될 만한 상황에서는 사용하기에 부적합하다.

또한 중간에 데이터 삽입 및 삭제 할 때도 매우 비효율 적이다.

단 장점은 indexing 이 되어있어 값에 접근에 있어 편리한 장점이있다.

**List** 는 Array 와 달리 크기를 지정하지 않아도 된다는 장점이 있다.
즉 크기가 정해져 있지 않기 때문에 데이터의 크기 를 알 수 없거나 사이즈가 변동 되는 상황에
사용하기 에 적합하다.

단, Array 와 마찬가지로 데이터의 삽입 및 삭제 시에 새로운 배열을 만들고
각 요소들을 복사하여 저장하는 작업이 일어나기때문에 삽입,삭제를 자주 하는 작업에는
비효율적이다.

**LinkedList** 는 List 와 같은 사이즈를 미리 정해두지 않고 사용하는 자료구조이며,
레퍼런스 형으로 각 노드들이 연결되어 있어서 데이터의 삽입,삭제 시 Array, List 보다
더 효율적이다.

단, 데이터 검색 및 접근시 모든 노드들을 거쳐가면서 데이터를 탐색하기 때문에 Array, List
보다 더 비효율 적인 단점이있다.

## 선형 리스트 
*(C# => List, C/C++ => 동적배열)*

### 2. 선형 리스트에 삭제 연산의 구현 방식에 대해 말해보세요

![RemoveList](./Images/RemoveList.png)

위의 그림처럼 하나의 인덱스 값에 접근하여 삭제를 요청할 경우

해당 자료구조를 똑같이 복사한후 기존의 구조에서 요청한 삭제 *인덱스 + 1* 이후 부터 마지막 요소까지
복사한 자료에 요청한 index 부터 마지막요소까지 복사하는 방식으로 삭제를 한다.

마지막값은 굳이 삭제시키지 않을 수도 있는데 그 이유는 전체 용량을 의미하는 Capacity 값과
현재 요소들의 갯수를 의미하는 Count 값으로 무시할수 있기 때문이다.

이러한 삭제연산은 보는것과 같이 비효율적인 연산을 한다.

#### 참고 : List의 시간복잡도

|접근 |탐색|삽입|삭제
|---|---|---|---|
|O(1)|O(n)|O(n)|O(n)|

## LinkedList

### 3. 연결리스트에 대해 설명해보세요

연결리스트는 연속적인 메모리 위치에 저장되지 **않는** 선형 데이터 구조이다.
노드 기반 데이터 구조이며 노드들간에 참조를 통해서 구현된다.
![LinkedList](./Images/LinkedList.png)

위의 예시는 이중연결 리스트의 구조를 만들어본것이다.

#### 장단점

장점
> 1. 동적 크기
> 2. 삽입, 삭제 의 용이

단점
> 1. 접근 하기 어려움 
> 2. 노드 기반 구조라 참조할때 사용할 데이터 공간이 더 필요하다.

#### LinkedList의 시간복잡도

|접근 |탐색|삽입|삭제
|---|---|---|---|
|O(n)|O(n)|O(1)|O(1)|


## 반복자 
*(Iterator , Enumerator)*

### 4. 반복자 패턴 에 대해 설명해보세요.

자료구조의 객체 내부 구조를 노출시키지 않고 순회 하는 방법을 제공하는 패턴이다.

객체 안에 들어있는 모든 항목에 접근하는 방식이 통일되어 있으면 
어떤 종류의 집합체에 대해서도 사용할 수 있는 다형적인 코드를 만들수 있게 된다.

장점

> 1. 클래스의 응집도를 높여준다.

>2. 자료구조 내에서 어떤 식으로 일이 처리되는지 알 필요 없이, 
	클래스 안에 들어있는 모든 항목에 접근 할 수 있게 해준다.

> 3.모든 요소에 일일이 접근하는 작업을 해당하는 클래스 객체가 아닌 이터레이터 객체에서 맡게 된다. 
	이렇게 하면, 집합체의 인터페이스 및 구현이 간단해질 뿐만 아니라, 
	집합체에서는 반복 작업에서 손을 떼고 원래 자신이 할 일에만 전념할 수 있다.
 
 단점

 > 단순한 순회를 구현하는 경우 클래스만 많아져 구조 복잡도가 증가할 수 있다.

 C#에서는  IEnumerable 인터페이스를 통해 구현할 수 있으며 C# 에서 구현되어있는
 다양한 자료구조들은 이미 이 인터페이스를 상속하고 있어서 이터레이터를 통한 연산을
 할 수 있다.



## 이진 탐색 트리 
*(Binary Search Tree)*

### 5. 이진 탐색 트리의 한계점과 해결 방법
![BinarySearchTreeProblem](./Images/BST_Problem.png)

위의 이미지 처럼 이진 탐색 트리는 노드들이 한쪽 자식으로만 추가되는 불균형이 발생 할 수 있다.

이러한 불균형이 생긴다면 
접근,탐색,삽입,삭제 작업의 모든 시간복잡도가 O(n)이 될수 있어서 이 자료구조를 사용하는 데 이점이 사라진다.

이러한 문제를 해결하기위해 자식 노드들의 균형을 맞추는 기능이있는 자가 균형 트리를 사용할 수있다. 
대표적인 자료구조로는 Red-Black Tree, AVL Tree 등이 있다.


### 6.이진탐색트리의 순회방법 및 순회 순서

이진 탐색 트리의 순회 방식은 중위 순회 방식을 사용하며
중위 순회시 오름차순 정렬 을 보장한다.

사용법 코드 예시

```cs
        public void Print() 
        {
            Print(root);
        }
        //중위순회하면서 print
        public void Print(Node node) 
        {
            if (node.Left != null) Print(node.Left);
            Console.WriteLine(" {0} ", node.Item);
            if (node.Right != null) Print(node.Right);
        }
```

설명:

<중위 순회방식>

1. 왼쪽 자식 노드가 있으면 왼쪽 자식 노드 출력 (그 자식노드의 자식이 있으면 반복해서 마지막 자식노드 부터 출력)

2. 그리고 본인(여기서는 node)을 출력

3. 오른쪽 자식 노드가 있으면 오른 쪽 자식 노드 출력 (그 자식노드의 자식이있으면 역시나 반복해서 마지막 노드 까지 출력)

## 해시 테이블
*(Hash Table)*

### 7. 해싱 과 해시 함수

해시란 : 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑하는 것을 말한다.

이러한 해시를 만들어주는 함수를 *해시 함수* 라고한다.

**해시테이블에서 해싱이란**

주어진 키값을 특정 규칙에 따라 해시테이블의 특정 인덱스로 치환해주는걸 해싱이라한다.

```cs

    //... 중략
         int hashCode = hashFunc(key); // 해시코드를 얻는다.
         int index = Math.Abs(hashCode) % table.Length;//나눗셈으로 해싱된 인덱스를만든다.
    //..중략
        // 기본적인 해시 함수
        private int HashFunc(TKey key)
        {
            if (key == null)
                throw new ArgumentNullException("key");

            return key.GetHashCode(); // 모든타입에대해 해시코드로 변환해준다.
        }


```

위의 코드에서 *int index = Math.Abs(hashCode) % table.Length;*
이 부분이 해시 테이블에서의 해시코드이다.

HashFunc함수의 구현이 *임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑하는 것* 을 의미한다.


**해시함수의 조건**

입력해대한 결과가 항상동일한 결과여야한다.(1:1 매칭)

**해시 함수의 효율**

>해시 함수자체가 느린경우 의미가 없다.
><br/>해시 함수의 결과가 밀집도가 낮아야한다! - 최대한 충돌을 피한다.
><br/>해시 테이블의 공간이 클수록 효율이 높다 - 역시나 충돌확률이 낮아진다.

**<해시테이블의 시간복잡도>**

|접근 |탐색|삽입|삭제
|---|---|---|---|
|X|O(1)|O(1)|O(1)|

### 7. 해시 테이블의 충돌과 충돌 방안

**<충돌해결방안 - 체이닝>**

해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식

>장점 : 해시테이블에 자료가 많아지더라도 성능저하가 적음
><br>단점 : 해시테이블 외 추가적인 저장공간이 필요
><br>(참고) 탐색법 : 키값을 먼저 찾은후 연결리스트에 Find 사용하면된다.

**<충돌해결방안 - 개방주소법>**

해시 충돌이 발생하면 다른 빈 공간에 데이터를 삽입하는 방식

해시 충돌시 선형탐색, 제곱탐색, 이중해시 등을 통해 다른 빈 공간을 선정

>장점 : 추가적인 저장공간이 필요하지 않음, 삽입삭제시 오버헤드가 적음
><br>단점 : 해시테이블에 자료가 많아질수록 성능저하가 많음




